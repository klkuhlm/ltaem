
module matrix_inverse
  use constants, only : DP
  implicit none
  private
  public :: inverse 
contains

  !##################################################
  ! using double-precision complex routines from LAPACK
  function inverse(ai) result(inv)

    ! interfaces to LAPACK generated by ifort -gen-interfaces
    ! LAPACK LU decomposition 
    INTERFACE 
       SUBROUTINE ZGETRF(M,N,A,LDA,IPIV,INFO)
         INTEGER, intent(in) :: LDA, M, N
         COMPLEX(KIND=8), intent(inout) :: A(LDA,*)
         INTEGER, intent(inout) :: IPIV(*)
         INTEGER, intent(inout) :: INFO
       END SUBROUTINE ZGETRF
    END INTERFACE

    ! LAPACK inverse calculation from results of LU
    INTERFACE 
       SUBROUTINE ZGETRI(N,A,LDA,IPIV,WORK,LWORK,INFO)
         INTEGER, intent(in) :: LDA, N
         COMPLEX(KIND=8), intent(inout) :: A(LDA,*)
         INTEGER, intent(inout) :: IPIV(*)
         COMPLEX(KIND=8), intent(inout) :: WORK(*)
         INTEGER, intent(in) :: LWORK
         INTEGER, intent(inout) :: INFO
       END SUBROUTINE ZGETRI
    END INTERFACE

    integer :: n, ierr
    integer, parameter :: LWORK = 6400
    complex(DP), dimension(:,:), intent(in) :: ai
    complex(DP), dimension(size(ai,1),size(ai,1)) :: inv
    integer, dimension(size(ai,1)) :: indx
    complex(DP), dimension(LWORK) :: work

    indx = 0
    n = size(ai,1)
    inv = ai    

    call zgetrf(n,n,inv,n,indx,ierr)
    if (ierr /= 0) write (*,*) 'error returned from ZGETRF'

    call zgetri(n,inv,n,indx,work,LWORK,ierr)
    if (ierr /= 0) write (*,*) 'error returned from ZGETRI'
    
  end function inverse

end module matrix_inverse

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
! ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

module leaky_q
  use constants, only : DP
  implicit none

  interface compute_CIleaky_q
     module procedure  compute_CIleaky_qv, compute_CIleaky_qs
  end interface

!!$  real(DP), save, allocatable :: root(:,:)

  private
  public :: compute_CIleaky_q

contains

  !! vector version useful during calc phase
  function compute_CIleaky_qv(p) result(q)
    use constants, only : DP, PI
    use element_specs, only : CInum, a2v,b2v,kv,av,leakv,k2v,b2v,sv,syv,kzv,unconfv,bgb

    integer, parameter :: NTERMS = 200, MAXITER = 200
    
    complex(DP), intent(in), dimension(:) :: p
    complex(DP), dimension(size(p),0:CInum) :: q

    integer :: i, ni, np
    complex(DP), dimension(size(p),0:CInum) :: kap2
    complex(DP), dimension(size(p)) :: exp2z

    !! boulton stuff
!!$    real(DP), dimension(NTERMS) :: guess, gamma
!!$    real(DP), dimension(0:CInum) :: sigma
!!$    complex(DP), dimension(size(p)) :: kernel
!!$    real(DP) :: x, delta
!!$    integer :: k, kk
!!$    logical, save :: first = .true.
    real(DP) :: boulton

    np = size(p)
    ni = CInum
!!$    sigma(0:ni) = sqrt(sv/Syv)

    do i=0,ni
       !! leaky-ness
       !! ##############################
       if(leakv(i) == 0) then
          !! no leaky layer, standard definition
          q(1:np,i) = p(1:np)/av(i)
       else
          kap2(1:np,i) = sqrt(p(:)/a2v(i))
          exp2z(1:np) = exp(-2.0_DP*kap2(:,i)*b2v(i))

          if(leakv(i) == 1) then
             !! case I, no-drawdown condition at top of aquitard
             q(:,i) = p(:)/av(i) + kap2(:,i)*k2v(i)/(bgb*kv(i))*&
                  & (1.0_DP + exp2z(:))/(1.0_DP - exp2z(:))
          elseif(leakv(i) == 2) then
             !! case II, no-flow condition at top of aquitard
             q(:,i) = p(:)/av(i) + kap2(:,i)*k2v(i)/(bgb*kv(i))*&
                  & (1.0_DP - exp2z(:))/(1.0_DP + exp2z(:))
          elseif(leakv(i) == 3) then
             !! aquitard thickness -> infinity
             q(:,i) = p(:)/av(i) + kap2(:,i)*k2v(i)/(bgb*kv(i))
          else
             stop 'ERROR: incorrect value for CIAquitardLeak parameter -> (1,2,3)'
          end if
       end if
       
       !! unconfined-ness 
       !! ##############################
       if(unconfv(i) == 0) then
          !! do nothing, q already computed above
       else
          !! Boulton unconfined source (Herrera infinite sum Kernel)
          !! guess is halfway between asymptotes of cot()
!!$
!!$          if (first) then
!!$             if(.not. allocated(root)) then
!!$                allocate(root(NTERMS,0:CInum))
!!$             end if
!!$             
!!$             !! roots are not a function of p (just sigma)- only compute once
!!$             guess(2:NTERMS) = PI*(real((/(k, k=1,NTERMS-1)/)) + 0.5_DP)/sigma(i)
!!$             guess(1) = 1.7D0
!!$
!!$             !! first root is hard to find with NR, 
!!$             !! use TS approximation for tangent and re-arrange
!!$             x = guess(1)
!!$             NR1: do kk = 1,MAXITER
!!$                delta = (x + (sigma(i) - 1.0_DP/sigma(i))*(x*sigma(i) + (x*sigma(i))**3/3.0_DP + &
!!$                     & 2.0_DP*(sigma(i)*x)**5/15.0_DP) + 17.0_DP*(x*sigma(i))**7/315.0_DP)/ &
!!$                     & (1.0_DP - (1.0_DP/sigma(i) - sigma(i))*(sigma(i) + x**2*sigma(i)**3 + &
!!$                     & 2.0_DP*x**4*sigma(i)**5/3.0_DP + 17.0_DP*x**6*sigma(i)**7/45.0_DP))
!!$                x = x - delta
!!$                if (abs(delta) <= 1.0D-10) then
!!$                   root(1,i) = x
!!$                   exit NR1
!!$                end if
!!$                if(kk == MAXITER) print *, '1 failed to converge'
!!$             end do NR1
!!$
!!$             do k = 2, NTERMS
!!$                x = guess(k)
!!$                NR: do kk = 1,MAXITER
!!$                   delta = (1.0_DP/tan(x*sigma(i)) + (sigma(i) - 1.0_DP/sigma(i))/x)/&
!!$                        & (sigma(i)/(sin(sigma(i)*x)**2) + (sigma(i) + 1.0_DP/sigma(i))/x**2)
!!$                   x = x + delta
!!$                   if (abs(delta) <= spacing(x)*10.0) then
!!$                      root(k,i) = x
!!$                      exit NR
!!$                   end if
!!$                   if(kk == MAXITER) print *, k,'failed to converge'
!!$                end do NR
!!$             end do
!!!!!$             if (i == ni) first = .false.
!!!!!$          end if
!!$
!!$          gamma(1:NTERMS) = Kzv(i)*root(1:NTERMS,i)**2/(bgb*Syv(i))
!!$
!!$          kernel(1:np) = 2.0_DP*sum(spread(gamma(1:NTERMS),2,np)/&
!!$               & ((spread(root(1:NTERMS,i)**2,2,np) - 1.0_DP + sigma(i)**2)* &
!!$               & (spread(p(1:np),1,NTERMS) + spread(gamma(1:NTERMS),2,np))),dim=1)
!!$          
!!$
!!$          q(1:np,i) = q(1:np,i) + p(1:np)*Syv(i)/Kv(i)*kernel

          ! scrap Herrera's infinite sum for Boulton's original
          ! rough-n-ready alpha, with a semi-physical expression for it
          boulton = 3.0_DP*Kzv(i)/(bgb*Syv(i))
          q(1:np,i) = q(:,i) + Syv(i)*p(1:np)*boulton/(Kv(i)*(boulton + p(1:np)))
       end if
    end do
    
    !! sources are only additive under the square root
    q = sqrt(q);

  end function compute_CIleaky_qv
  
  !! scalar version useful in matching
  function compute_CIleaky_qs(p) result(q)
    use constants, only : DP
    use element_specs, only : CInum

    complex(DP), intent(in) :: p
    complex(DP), dimension(0:CInum) :: q

    !! sum away singleton first dimension
    q(0:CInum) = sum(compute_CIleaky_qv( (/p/)),dim=1)

  end function compute_CIleaky_qs
  

end module leaky_q
  
